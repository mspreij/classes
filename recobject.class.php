<?php
class recobject {
	
/** -- Functions -------------------------
 * 
 * recobject($table, $fields, $id=0, $clause=false)     -- Constructor: string $table, array $fields, int $id, array $clause
 * select()                                             -- Fetches row, sets $this->fields items with update_object(), returns row.
 * set_clause($array)                                   -- Adds assoc array (field/value) to use in all queries [2008-02-07 12:14:44]
 * add_clause($array)                                   -- Adds to current clause (instead of replacing like set_clause), does overwrite items if they were specified again
 * set_clause_string()                     [protected]  -- Helper method for set/add_clause(), sets clause_string (yes, really)
 * insert($extra='')                                    -- Gets data with get_data(), inserts record, calls select() to update object, returns id or false.
 * update($extra='')                                    -- Gets data with get_data(), updates record, calls select() to update object.
 * validate($data, $type)                               -- 
 * update_object($data)                                 -- fills $this->fields array with passed assoc array (prime candidate for private method in PHP5)
 * get_data($type='')                                   -- Grabs $_POST/GET value (if isset()) for each key in $fields, returns assoc array.
 * hook($name, $function)                               -- register $function to run in $name -> method name. $function can also be the result of create_function(),
                                                           or an anonymous function (closure) in PHP 5.3+. AND it accepts array($object or 'object_name', 'method')
                                                           as $function, too.
 * run_hooks($hook, &$data)                             -- Called by various functions, allows "extending" them without extending the class
 * delete()                                             -- Just deletes the record. Extend class to deal with subrecords, files etc
 * get_list($options='')                                -- what it says, returns array. Also runs update_object hook on each item (as of this writing)
 * styledText($string, $color='#000')                   -- "meh"
 * reset()                                              -- returns the object to a pre-$id state
 * 
**/
	
	public $table;                   // string,       tablename
	public $fields;                  // array,        fields[name] => value
	public $id;                      
	public $clause;                  // assoc array,  field=>'value'
	public $clause_string;           // " AND `foo` = 'ba\'ar'", generated by the set_clause() method, for use in Select, Update, Delete SQL
	public $debug            = False;  
	public $show_errors      = 1;      // 1: errors, 2: warnings, 3: notices, 0: fail silently.
	public $messages         = array();
	public $logging          = True;   // log events to logbook table
	public $record_created   = "Record created.";
	public $record_updated   = "Record updated.";
	public $validation_error = '';
	public $validation_text  = 'Failed to save, invalid data: ';
	
	// -- Constructor -----------------------
	function __construct($table, $fields, $id=0, $clause=false) {
		// set debug to constant DEBUG, if any
		if (defined('DEBUG')) $this->debug = (int) DEBUG;
		$this->table = $table;
		if (is_array($fields)) {
			foreach($fields as $field) $this->fields[$field] = '';
		}else{
			trigger_error('recobject class error: $fields should be array in constructor', E_USER_WARNING);
		}
		$this->id = $id;
		$this->clause = array(); // init.
		if ($clause) $this->set_clause($clause);
		if (! ($table && $fields)) trigger_error('recobject class error: Missing table or fields in constructor', E_USER_WARNING);
		if ($this->id) {
			$this->select();
		}
	}
	
	//______________________
	// select($id = false) /
	function select($id = false) {
		if ($id) $this->id = $id;
		if (! $this->id) {
			$this->messages[] = $this->styledText("Can't select data, no id given.", 'red');
			return false;
		}
		if (is_array($this->id)) {
			$sql = "SELECT id, `". join('`, `', array_keys($this->fields)) ."` FROM $this->table WHERE ";
			foreach ($this->id as $key => $val) {
				$sql .= "`".mysql_real_escape_string($key)."` = '".mysql_real_escape_string($val)."' AND ";
			}
			$sql = substr($sql, 0, -4);
		}else{
			$sql = "SELECT `". join('`, `', array_keys($this->fields)) ."` FROM $this->table WHERE id = '$this->id'";
		}
		if ($this->clause) $sql .= $this->clause_string; // clause
		if ($this->debug) echo $this->styledText($sql."<br>\n", 'blue');
		if ($res = mysql_query($sql)) {
			if (mysql_num_rows($res) > 1) { // [2011-09-13 14:45:24]
				// You specified an $id, I'm assuming you want a single record, but I found more.
				// If you want to select a subset of records based on some filter, use null or false for $id and use the $clause instead.
				trigger_error(get_class($this) ." class error: more than one row match this \$id (use \$clause to find a subset of records if that was the objective)", E_USER_ERROR);
				return false;
			}elseif ($row = mysql_fetch_assoc($res)) {
				if (is_array($this->id)) $this->id = (int) array_shift($row);
				$this->update_object($row);
				return $this->fields; // [2010-12-20 17:03:59]
			}else{
				$this->id = false; // the query worked, clearly there is No Such Record.
				$this->messages[] = $this->styledText(get_class($this) .": Record not found..", 'red');
				return false;
			}
			return $row;
		}else{
			trigger_error("Select error: ". mysql_error(), E_USER_WARNING);
			return false;
		}
	}
	
	//_____________________
	// set_clause($array) /
	function set_clause($array) {
		if (! is_array($array)) { //  && count($array)
			trigger_error(__CLASS__.'->set_clause() error, argument should be a (non-empty) array,', E_USER_WARNING);
			return false;
		}
		$this->clause = $array;
		$this->set_clause_string();
		return true;
	}
	
	//________________________
	// -- add_clause($array) /
	function add_clause($array) {
		if (! is_array($array)) {
			trigger_error(__CLASS__.'->add_clause() error, argument should be a (non-empty) array,', E_USER_WARNING);
			return false;
		}
		foreach ($array as $key => $value) {
			$this->clause[$key] = $value; // overwrites as needed
		}
		$this->set_clause_string();
		return true;
	}
	
	//______________________
	// set_clause_string() /
	protected function set_clause_string() {
		$this->clause_string = ''; // resets if it was not empty
		foreach($this->clause as $field => $value) {
			if (is_numeric($field)) {
				trigger_error(__CLASS__."->add_clause(): I'm pretty sure table column names shouldn't be numeric (".var_export($field, 1)."). If your query breaks, this caused it.",
				              E_USER_WARNING);
			}
			$this->clause_string .= " AND `$field` = '".mysql_real_escape_string($value)."'";
		}
	}
	
	//____________________
	// insert($extra='') /
	function insert($extra='') {
		$data = $this->get_data('insert');
		if (is_array($extra)) foreach($extra as $key => $val) $data[$key] = $val;
		if ($data) {
			$this->run_hooks('pre_insert', $data);
			// Validate
			if (! $this->validate($data, 'insert')) {
				$this->messages[] = $this->styledText($this->validation_text . $this->validation_error, '#f80');
				return False;
			}
			if ($this->clause) $data = array_merge($data, $this->clause); // clause
			foreach ($data as $key => $value) {
				if (is_array($value)) {
					$data[$key] = json_encode($value);
					// if ($this->show_errors > 1) $messages[] = $this->styledText("Warning: ->insert(): json_encoded value for field '$key' (was an array). It's better to handle this in a get_data() hook.", '#f80');
					trigger_error("->insert(): json_encoded value for field '$key' (was an array). It's better to handle this in a get_data() hook.", E_USER_NOTICE);
				}
			}
			$sql = "
				INSERT INTO $this->table (`". join('`, `', array_keys($data)) ."`)
				VALUES ('". join("', '", array_map('mysql_real_escape_string', $data)) ."')";
			if ($this->debug) echo $this->styledText($sql."<br>\n", 'green', 'p');
			if ($res = mysql_query($sql)) {
				if ($this->record_created) $this->messages[] = $this->record_created;
				$this->id = mysql_insert_id();
				$this->select();
				if ($this->logging) writelog("Insert\n$sql", -1, 'cms');
				$this->run_hooks('post_insert', $data);
				return $this->id;
			}else{
				trigger_error("Insert error: ". mysql_error(), E_USER_WARNING);
				writelog("insert error:  $sql\n\n". mysql_error());
				return false;
			}
		}else{
			$this->messages[] = $this->styledText("->insert: No data", 'red');
			return false;
		}
	}
	
	//____________________
	// update($extra='') /
	function update($extra='') {
		$data = $this->get_data('update');
		if (is_array($extra)) foreach($extra as $key => $val) $data[$key] = $val;
		if ($data) {
			$this->run_hooks('pre_update', $data);
			// Validate
			if (! $this->validate($data, 'update')) {
				$this->messages[] = $this->styledText($this->validation_text . $this->validation_error, '#f80');
				return False;
			}
			$sql = "UPDATE $this->table SET\n";
			foreach($data as $key => $value) {
				if (is_array($value)) {
					$value = json_encode($value);
					// if ($this->show_errors > 1) $messages[] = $this->styledText("Warning: ->update(): json_encoded value for field '$key' (was an array). It's better to handle this in a get_data() hook.", '#f80');
					trigger_error("->update(): json_encoded value for field '$key' (was an array). It's better to handle this in a get_data() hook.", E_USER_NOTICE);
				}
				$sql .= "`$key` = '". mysql_real_escape_string($value) ."', ";
			}
			$sql = substr($sql, 0, -2) ." WHERE id = '$this->id'";
			if ($this->clause) $sql .= $this->clause_string; // clause
			if ($this->debug) echo $this->styledText($sql."<br>\n", '#C60');
			if ($res = mysql_query($sql)) {
				if ($this->record_updated) $this->messages[] = $this->record_updated;
				$data = $this->select();
				if ($this->logging) writelog("Update\n$sql", -1, 'cms');
				$this->run_hooks('post_update', $data);
				return true;
			}else{
				trigger_error("Update error: ". mysql_error(), E_USER_WARNING);
				return false;
			}
		}else{
			$this->messages[] = $this->styledText("->update: No data", 'red');
			return false;
		}
	}
	
	//_____________________________________________
	// set($data=>array(), $force_update = false) /
	// function set($data=array(), $force_update = false) {
	// 	global $messages;
	// 	if (! is_array($data) or empty($data)) {
	// 		trigger_error('->set requires a non-empty array, ignored '.is_array($data) ? 'empty array' : gettype($data), E_USER_WARNING);
	// 		return false;
	// 	}
	// 	if ($count = count(array_diff_key($data, $this->clause))) {
	// 		if ($count == count($data) or $force_update) {
	// 			// do update, update $this->fields
	// 		}else{
	// 			trigger_error('->set got keys which are also in the clause, ', E_USER_WARNING);
	// 			return false;
	// 		}
	// 	}else{
	// 		trigger_error('->set requires a non-empty array, ignored '.is_array($data) ? 'empty array' : gettype($data), E_USER_WARNING);
	// 		return false;
	// 	}
	// }
	
	//_________________________
	// validate($data, $type) /
	function validate($data, $type) {
		// $this->validation_error = '...';
		return true;
	}
	
	//_______________________ -- private
	// update_object($data) /
	function update_object($data) {
		$this->run_hooks('update_object', $data);
		foreach($data as $key => $value) {
			$this->fields[$key] = $value;
		}
	}
	
	//_____________________
	// get_data($type='') /
	function get_data($type='') {
		$data = array();
		$_request = array_merge($_GET, $_POST); // [2010-04-01 20:35:02]
		foreach(array_keys($this->fields) as $field) {
			if (isset($_request[$field])) {
				$data[$field] = $_request[$field]; // [2009-11-21 17:42:42]
			}
		}
		$this->run_hooks('get_data', $data);
		return $data;
	}
	
	//_________________________ register custom functions, added [2008-11-15 19:05:38]
	// hook($name, $function) /
	function hook($name, $function) {
		$this->hooks[$name][] = $function;
		// that's the meat of it; now we'll just check if it was useful, and throw warnings/errors otherwise.
		if (is_string($function)) {
			if (! function_exists($function)) {
				if ($this->show_errors > 1) {
					trigger_error("Hook function '$function' is not defined (yet)!", E_USER_NOTICE);
				}
			}
		}elseif(is_array($function)) {
			if (count($function)==2) {
				if (! method_exists($function[0], $function[1])) {
					trigger_error("Hook method '". $function[1] ."' is not defined in Class '".(is_string($function[0]) ? $function[0] : get_class($function[0]))."'!", E_USER_ERROR); // Blam!
				}
			}else{
				trigger_error(get_class($this) ."->hook() parameter error: [object,method] array should have exactly 2 items.", E_USER_WARNING);
				return false;
			}
		}elseif(is_object($function) && strtolower(get_class($function)) == 'closure'){
			// cool?
		}else{
			trigger_error(get_class($this) ."->hook() did not expect to get a function of type '". gettype($function) ."', there. Try string or array (for methods).", E_USER_WARNING);
			return false; // that made no sense.
		}
		// Special case: hooks are only added once the record is initialized - and selected. update_object() is called inside the select method.
		// So, we re-fetch it and let it run the hook stuff.
		if ($name == 'update_object') {
			// if ($this->id) $this->select();      // <-- that one re-queries, but we already have all the data (maybe?) so that shouldn't be needed. [2011-11-08 21:55:33]
			$this->run_hooks($name, $this->fields); // Todo: prove this works the way it should and has no weird side effects >.<
		}
		return $this; // [2011-09-12 12:33:23] will this work?
	}
	
	//___________________________ [2009-11-22 01:20:09]
	// run_hooks($hook, &$data) /
	function run_hooks($hook, &$data) {
		if (isset($this->hooks[$hook])) {
			foreach ($this->hooks[$hook] as $function) {
				if (is_string($function)) {
					if (function_exists($function)) {
						$data = $function($data);
					}else {
						trigger_error("Error: could not run hook function '$function': not defined.<br />", E_USER_ERROR);
					}
				}elseif(is_array($function)) {
					if (count($function)==2) {
						if (method_exists($function[0], $function[1])) {
							$data = $function[0]->$function[1]($data);
						}else{
							trigger_error("Hook method '". $function[1] ."' from Class '".(is_string($function[0]) ? $function[0] : get_class($function[0]))."' does not exist.", E_USER_ERROR);
						}
					}else{
						trigger_error(get_class($this) ."->run_hooks() parameter error: [object,method] array should have exactly 2 items.", E_USER_NOTICE);
					}
				}elseif(is_object($function) && strtolower(get_class($function)) == 'closure') {
					$data = $function($data);
				}
			}
		}
	}
	
	//___________
	// delete() /
	function delete() {
		$post_delete_data = '';
		$sql = "DELETE FROM $this->table WHERE id = '$this->id'";
		if ($this->clause) $sql .= $this->clause_string;
		if ($this->debug) echo $this->styledText($sql."<br>\n", 'purple');
		if (isset($this->hooks['post_delete']) && $this->hooks['post_delete'] or $this->logging) {
			$post_delete_data = fetch_row("SELECT * FROM $this->table WHERE id = '$this->id'");
		}
		if ($this->logging) {
			$log  = "Delete\n$sql\nWas:";
			$log .= print_r($post_delete_data, true);
		}
		$res = mysql_query($sql);
		if ($res) {
			$this->run_hooks('post_delete', $post_delete_data);
			if ($this->logging) writelog($log, -1, 'backup');
			$this->id = false;
			foreach ($this->fields as $key => $value) $this->fields[$key] = null;
			// foreach ($this->fields as $key => &$value) $value = null;
			// unset($value);
		}else{
			writelog('Failed query: '. $log, 2, 'cms');
		}
		return $res;
	}
	
	
	//________________________
	// get_list($options='') /
	function get_list($options='') {
		if (is_array($options)) {
			extract($options);
		}
		// put together query:
		$sql = "SELECT id, "; // you get id for FREE!
		foreach(array_keys($this->fields) as $field) $sql .= "`$field`, ";
		$sql = substr($sql, 0, -2) ." FROM `$this->table`";
		if (isset($where))   $sql .= " WHERE $where";
		if ($this->clause)   {
			$sql .= (isset($where) ? $this->clause_string : ' WHERE '.substr($this->clause_string, 4)); // clause, copied from ->select
		}
		if (isset($groupby)) $sql .= " GROUP BY $groupby";
		if (isset($orderby)) $sql .= " ORDER BY $orderby";
		if (isset($limit))   $sql .= " LIMIT $limit";
		// now execute it.
		if ($this->debug) echo $this->styledText($sql."<br>\n", 'blue');
		if ($res = mysql_query($sql)) {
			if (mysql_num_rows($res)) {
				while($row = mysql_fetch_assoc($res)) {
					$this->run_hooks('update_object', $row); // [2011-08-11 03:57:32] woah!
					$data[] = $row;
				}
				// writelog(var_export($data, 1), -1);
				return $data;
			}else{
				return array(); // [2010-12-12 21:50:27]
			}
		}else{
			trigger_error("->get_list() error: ". mysql_error() ."<br>$sql<br>\n", E_USER_WARNING);
			return false;
		}
	}
	
	//_____________________________________
	// styledText($string, $color='#000') /
	function styledText($string, $color='#000') {
		return "<span style='color: $color;'>$string</span>"; // christ. there. happy now?
	}
	
	// "experimental"
	function reset() {
		$this->id = false;
		foreach ($this->fields as $key => $value) {
			$this->fields[$key] = null;
		}
	}
	
} // End of Base Class


/* -- Log --------------------------------

[2012-01-10 22:25:36] Added ->validation_text property, used in insert/update
[2011-12-13 17:05:43] Yanked global $messages
[2011-11-08 21:55:33] Patched hooks->update_object to not re-select but run on already-fetched data ($this->fields). It /seems/ to work, but...
[2011-10-29 09:10:59] get_list() echoes $sql if $this->debug
[2011-10-28 03:49:23] Added add_clause() and set_clause_string()
[2011-10-27 07:21:10] Init'ing ->clause to empty array in constructor. Playing with ->add_clause() in child classes, should add some day.
[2011-09-27 06:27:52] Only stuffing $this->record_inserted/updated in $messages if they're truthy (this mess still needs to be fixed)
[2011-09-13 14:45:24] Updated ->select() to check for more than 1 row found, which could happen when using array(field:val) as $id
[2011-09-12 12:19:38] Replaced bunch of $messages[]=.. with trigger_error() calls, if they are "code logic" errors.
[2011-08-11 03:57:32] Patched get_list() to run update_object hooks on result list. /might/ just have to make this optional..
                      Replaced mres calls with mysql_real_escape_string.
[2011-07-29 23:18:15] Fixed hook method: update_object wouldn't re-select() if the callback function was a closure.
[2011-07-23 14:25:11] "Added" styledText() as method to rely less on non-class functions, but jeez, we need some proper error reporting in here.
[2011-01-09 20:53:31] Added ->validate($data, $type) & (string) property ->validation_error. ->validate($data, $type) returns true by default
[2010-12-27 18:13:27] Added $type arg to get_data() because YOU NEVER KNOW and it turned out to be maybe useful somewhere (reverts [2010-12-01 20:07:12]).
[2010-12-20 17:03:59] select() used to return $row, now it returns $this->fields, after update_object() has had its way with it, so that any hooks/overrides
                      that affect $this get back with the select data too.
[2010-12-12 21:50:27] get_list() now returns an empty array instead of 0, when there were no errors but no records either
[2010-12-01 20:50:38] patched ->hook() and run_hooks() to support anonymous functions (AKA closures). create_function() was already supported (it turns out to
                      basically be a wrapper for eval() and returns a function-name string).
[2010-12-01 20:07:12] Removed $type arg from get_data(), wasn't used (it used to be called with 'insert' and 'update', from those methods).
                      Added "pre_insert" and "pre_update" hooks in those methods
[2010-11-30 14:42:49] update_object() now actually checks for its hooks (->hook('update_object',..) will call select() if $this->id, which then calls update_object())
[2010-11-04 15:49:15] Updated update() and insert() to json_encode any array values in $data, and give a warning.
                      Added ->show_errors property, that should be used instead of ->debug in various places
                      Updated delete(), post_delete hook now gets the whole row instead of just the id (useful for deleting images that were named in the
                      record etc)
[2010-11-03 19:02:55] Updated select() with optional $id param: if $id is only known after object creation, $R->select($id) will set it and request the data
[2010-10-27 13:42:17] $id in the Constructor can now also be an assoc array, $this->id is reset as soon as it finds the record. The clause is still also used.
[2010-07-06 13:46:28] Added get_list(), copied from InfoBuddy
[2010-04-01 20:35:02] Re-incarnating $_REQUEST as $_request, since the former contained _COOKIE as well, which could contain parameters that were also defined
                      fieldnames - fun fun fun.
[2010-03-27 17:27:01] Allowed unsetting clause() with an empty array (so easy, so useful - why'd it take so long?!)

[2010-03-12 00:41:26] ->hook/run_hooks now accept array(object, method) as function to run. I rule.
[2010-02-28 22:23:01] Made sure the hooks actually *ran*, too.
[2009-11-18 14:33:06] Allow multiple hook functions for the same hook
[2009-06-12 04:46:25] debug sql is now actually echo'd in $this->delete. (doh)
[2009-02-08 01:58:18] fixed select(), if a record doesn't exists it sets $this->id to false and complains. Otherwise, it now returns the $row.
[2008-12-07 01:21:09] delete() now logs errors regardless of $this->logging
[2008-11-15 19:37:39] Delete foreach($this->fields as $key => &$value) not working well under older PHP (I think?), rewrote.
[2008-11-15 19:05:38] Added hook method: accepts name of method to apply in (only get_data for now), and name of [custom] function to run.
                      Custom function must accept $data and return $data in get_data(), maybe other method-custom-calls get other requirements.
[2008-10-11 16:27:27] ->delete() now sets fields to null and $id to false on successful delete, logs on failure.


Todo: finish ->set(), clause thing: the override will update the record for anything not in the clause, if there's anything left. But if those keys
      that /are/ in the clause as well have the /same values/, update without the override (and throw a notice or something).
      Also also: check add_clause() doesn't invalidate the current record, if any. Yell loudly if that happens.
Todo: implement parameterized SQL queries - though that might require either moving to mysqli, adding some abstraction class, or a bunch of methods that
Todo:   wrap queries for both interfaces.
TODO: Sort out debug vs show_errors, go through code applying correct one
Todo: Consider set_key() method, key property (key/clause, even?)
Todo: Introduce toggles for the returning of status messages, or something.. $this->record_updated is not exactly optimal.
Todo: Minimize dependencies on misc custom functions
Todo: find [2011-11-08 21:55:33], prove that works, with/out $id, for different hook function types (string, closure, method, yadda..)
Todo: have hook() accept optional arguments to pass to the callback function (as 3rd arg, not array, that's already used and adding more items to that would
      get /confusing/). The ->hooks array would require sub-arrays instead of function names - which it already /does/ for methods.. will *they* ever need
      arguments? Or make sub-arrays the standard, [function, [args]] where function can be a sub-sub-array for methods. Also, check where other callbacks might
      come in handy.

*/
